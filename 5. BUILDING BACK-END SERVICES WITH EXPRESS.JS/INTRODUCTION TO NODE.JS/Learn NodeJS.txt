# LEARN NODE.JS
---------------

* Introduction
--------------
2 min
For a long time, the browser was the only place JavaScript code could be executed. Web developers had to use a different programming language on the front-end than the back-end. It also 
meant that, even as JavaScript evolved into a more robust and powerful language, it remained a front-end only language.

Though multiple attempts to create off-browser JavaScript environments have been attempted, Node.js, invented by Ryan Dahl in 2009, found unprecedented popularity and is currently being 
used by numerous top-tier companies including Netflix, Uber, Paypal, and eBay. Node.js is a JavaScript runtime, or an environment that allows us to execute JavaScript code outside of the 
browser. A “runtime” converts code written in a high-level, human-readable, programming language and compiles it down to code the computer can execute.

Though Node was created with the goal of building web servers and web applications in JavaScript, it can also be used for creating command-line applications or desktop applications. In 
this lesson, we’ll explore some features of Node so you start to feel comfortable with running JavaScript in the Node environment and gain some familiarity with features unique to Node. 
For more advanced development, Node can be combined with any number of robust frameworks like the Express.js framework for creating effective web application back-ends.

There’s more to learn about Node than we could ever fit in one lesson. We’ll try to point to great resources like MDN and the Node.js documentation. Take your time exploring and use the 
documentation.

* Instructions
--------------
Checkpoint 1 Passed
1.
In this lesson, we’ll be providing you a terminal with Node.js already installed. If you’d like to download Node on your local machine and follow along, check out this article.

Let’s see what version of Node we have installed. Type node -v in the terminal and then press and hit enter (or return).

-------------------------------------------------------------------------------------------------------------------------------------------------------------------

* The Node REPL
---------------
6 min
REPL is an abbreviation for read–eval–print loop. It’s a program that loops, or repeatedly cycles, through three different states: a read state where the program reads input from a user, 
the eval state where the program evaluates the user’s input, and the print state where the program prints out its evaluation to a console. Then it loops through these states again.

When you install Node, it comes with a built-in JavaScript REPL. You can access the REPL by typing the command node (with nothing after it) into the terminal and hitting enter. A > 
character will show up in the terminal indicating the REPL is running and prompting your input. The Node REPL will evaluate your input line by line.

By default, you indicate the input is ready for eval when you hit enter. If you’d like to type multiple lines and then have them evaluated at once you can type .editor while in the REPL. 
Once in “editor” mode, you can type control + d when you’re ready for the input to be evaluated. Each session of the REPL has a single shared memory; you can access any variables or 
functions you define until you exit the REPL.

A REPL can be extremely useful for performing calculations, learning a language, and developing code. It’s a place where you can explore language features and try things out while 
receiving immediate feedback. Figuring out how to do this outside of the browser or a website can be really empowering.

The Node environment contains a number of Node-specific global elements in addition to those built into the JavaScript language. Every Node-specific global property sits inside the the 
Node global object. This object contains a number of useful properties and methods that are available anywhere in the Node environment.

Let’s try out the Node REPL. This will be a good way for you to explore the Node global object!

* Instructions
--------------
Checkpoint 1 Passed
1.
Let’s enter the Node REPL. Type node in the terminal and press enter.

Checkpoint 2 Passed
2.
Experiment on your own within the REPL to get a better sense of it. Here are some suggestions for things to try:

	. Access the global object. You can console.log(global) or, since the REPL displays the return of each evaluated line, simply type global and then enter.

	. Woah… it looks huge. A lot of that is because of the global.process object. Check out an easier to read list of the properties on the global object with Object.keys(global).

	. The global object has a lot of useful properties and methods, and it’s not common to add any to it. However, it is just an object, so we can! Add a property to the global 
	object, eg. global.cat = 'meow!'.

	. Now print or return the property you just added:

> console.log(global.cat)
'meow!'

	. If you’re familiar with running JavaScript on the browser, you’ve likely encountered the Window object. Here’s one major way that Node differs: try to access the Window object 
	(this will throw an error). The Window object is the JavaScript object in the browser that holds the DOM, since we don’t have a DOM here, there’s no Window object.

You’ll learn more about the global object as you explore Node, but remember that, at its core, it’s just a JavaScript object!

bash
----
$ node
> console.log(global)
{ global: [Circular],
  process: 
   process {
     title: '/usr/bin/node',
     version: 'v7.10.1',
     moduleLoadList: 
      [ 'Binding contextify',
        'Binding natives',
        'NativeModule events',
        'Binding config',
        'Binding icu',
        'NativeModule util',
        'Binding uv',
        'NativeModule buffer',
        'Binding buffer',
        'Binding util',
        'NativeModule internal/util',
        'NativeModule internal/buffer',
        'NativeModule timers',
        'Binding timer_wrap',
        'NativeModule internal/linkedlist',
        'NativeModule assert',
        'NativeModule internal/process',
        'NativeModule internal/process/warning',
        'NativeModule internal/process/next_tick',
        'NativeModule internal/process/promises',
        'NativeModule internal/process/stdio',
        'Binding constants',
        'NativeModule internal/url',
        'NativeModule internal/querystring',
        'Binding url',
        'NativeModule querystring',
        'NativeModule os',
        'Binding os',
        'NativeModule tty',
        'NativeModule net',
        'NativeModule stream',
        'NativeModule internal/streams/legacy',
        'NativeModule _stream_readable',
        'NativeModule internal/streams/BufferList',
        'NativeModule _stream_writable',
        'NativeModule _stream_duplex',
        'NativeModule _stream_transform',
        'NativeModule _stream_passthrough',
        'NativeModule internal/net',
        'Binding cares_wrap',
        'Binding tty_wrap',
        'Binding tcp_wrap',
        'Binding pipe_wrap',
        'Binding stream_wrap',
        'NativeModule internal/repl',
        'NativeModule readline',
        'NativeModule internal/readline',
        'NativeModule repl',
        'NativeModule internal/module',
        'NativeModule vm',
        'NativeModule path',
        'NativeModule fs',
        'Binding fs',
        'Binding fs_event_wrap',
        'NativeModule internal/fs',
        'NativeModule console',
        'Binding signal_wrap',
        'NativeModule module',
        'NativeModule domain',
        'NativeModule string_decoder' ],
     versions: 
      { http_parser: '2.7.0',
        node: '7.10.1',
        v8: '5.5.372.43',
        uv: '1.11.0',
        zlib: '1.2.11',
        ares: '1.10.1-DEV',
        modules: '51',
        openssl: '1.0.2k',
        icu: '58.2',
        unicode: '9.0',
        cldr: '30.0.3',
        tz: '2016j' },
     arch: 'x64',
     platform: 'linux',
     release: 
      { name: 'node',
        sourceUrl: 'https://nodejs.org/download/release/v7.10.1/node-v7.10.1.tar.gz',
        headersUrl: 'https://nodejs.org/download/release/v7.10.1/node-v7.10.1-headers.tar.gz' },
     argv: [ '/usr/bin/nodejs' ],
     execArgv: [ '--max-old-space-size=200' ],
     env: 
      { HOSTNAME: '1c3834addbf0',
        GEM_HOME: '/home/ccuser/.gem/ruby/2.3.0',
        TERM: 'xterm',
        EXPIRES_AT: '1713200025',
        NLTK_DATA: '/home/ccuser/.nltk_data',
        PATH: '/home/ccuser/.bin:/home/ccuser/node_modules/.bin:/home/ccuser/.gem/ruby/2.3.0/bin:/home/ccuser/.bin:/home/ccuser/node_modules/.bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin',
        _: '/usr/bin/node',
        CODEX_RUNNER_PATH: '/var/codecademy/codex/runners',
        PWD: '/home/ccuser/workspace/srg-blank-workspace',
        SESSION_ID: '4b168326-4627-4e60-9fa9-8fd94d71f5c0',
        LANG: 'en_US.UTF-8',
        TZ: 'Etc/UTC',
        LOG_LEVEL: '2',
        HOME: '/home/ccuser',
        SHLVL: '2',
        WORKSPACE_SERVICE_HOST: 'https://workspace.production-eks.codecademy.com',
        EIN_IMAGE: 'node',
        PYTHONPATH: '/var/codecademy/runner_contexts/python:' },
     pid: 43,
     features: 
      { debug: false,
        uv: true,
        ipv6: true,
        tls_npn: true,
        tls_alpn: true,
        tls_sni: true,
        tls_ocsp: true,
        tls: true },
     _needImmediateCallback: false,
     execPath: '/usr/bin/nodejs',
     debugPort: 5858,
     _startProfilerIdleNotifier: [Function: _startProfilerIdleNotifier],
     _stopProfilerIdleNotifier: [Function: _stopProfilerIdleNotifier],
     _getActiveRequests: [Function: _getActiveRequests],
     _getActiveHandles: [Function: _getActiveHandles],
     reallyExit: [Function: reallyExit],
     abort: [Function: abort],
     chdir: [Function: chdir],
     cwd: [Function: cwd],
     umask: [Function: umask],
     getuid: [Function: getuid],
     geteuid: [Function: geteuid],
     setuid: [Function: setuid],
     seteuid: [Function: seteuid],
     setgid: [Function: setgid],
     setegid: [Function: setegid],
     getgid: [Function: getgid],
     getegid: [Function: getegid],
     getgroups: [Function: getgroups],
     setgroups: [Function: setgroups],
     initgroups: [Function: initgroups],
     _kill: [Function: _kill],
     _debugProcess: [Function: _debugProcess],
     _debugPause: [Function: _debugPause],
     _debugEnd: [Function: _debugEnd],
     hrtime: [Function: hrtime],
     cpuUsage: [Function: cpuUsage],
     dlopen: [Function: dlopen],
     uptime: [Function: uptime],
     memoryUsage: [Function: memoryUsage],
     binding: [Function: binding],
     _linkedBinding: [Function: _linkedBinding],
     _events: 
      { warning: [Function],
        newListener: [Function],
        removeListener: [Function],
        SIGWINCH: [Object] },
     _rawDebug: [Function],
     _eventsCount: 4,
     domain: [Getter/Setter],
     _maxListeners: undefined,
     _fatalException: [Function],
     _exiting: false,
     assert: [Function],
     config: { target_defaults: [Object], variables: [Object] },
     emitWarning: [Function],
     nextTick: [Function: nextTick],
     _tickCallback: [Function: _tickDomainCallback],
     _tickDomainCallback: [Function: _tickDomainCallback],
     stdout: [Getter],
     stderr: [Getter],
     stdin: [Getter],
     openStdin: [Function],
     exit: [Function],
     kill: [Function],
     argv0: '/usr/bin/node' },
  Buffer: 
   { [Function: Buffer]
     poolSize: 8192,
     from: [Function],
     alloc: [Function],
     allocUnsafe: [Function],
     allocUnsafeSlow: [Function],
     isBuffer: [Function: isBuffer],
     compare: [Function: compare],
     isEncoding: [Function],
     concat: [Function],
     byteLength: [Function: byteLength] },
  clearImmediate: [Function],
  clearInterval: [Function],
  clearTimeout: [Function],
  setImmediate: [Function],
  setInterval: [Function],
  setTimeout: [Function],
  console: [Getter],
  module: 
   Module {
     id: '<repl>',
     exports: {},
     parent: undefined,
     filename: null,
     loaded: false,
     children: [],
     paths: 
      [ '/home/ccuser/workspace/srg-blank-workspace/repl/node_modules',
        '/home/ccuser/workspace/srg-blank-workspace/node_modules',
        '/home/ccuser/workspace/node_modules',
        '/home/ccuser/node_modules',
        '/home/node_modules',
        '/node_modules',
        '/home/ccuser/.node_modules',
        '/home/ccuser/.node_libraries',
        '/usr/lib/node' ] },
  require: 
   { [Function: require]
     resolve: [Function: resolve],
     main: undefined,
     extensions: { '.js': [Function], '.json': [Function], '.node': [Function] },
     cache: {} } }
undefined
> Object.keys(global)
[ 'global',
  'process',
  'Buffer',
  'clearImmediate',
  'clearInterval',
  'clearTimeout',
  'setImmediate',
  'setInterval',
  'setTimeout',
  'console',
  'module',
  'require' ]
> global.cat = 'meow'
'meow'
> Object.keys(global)
[ 'global',
  'process',
  'Buffer',
  'clearImmediate',
  'clearInterval',
  'clearTimeout',
  'setImmediate',
  'setInterval',
  'setTimeout',
  'console',
  'module',
  'require',
  'cat' ]
> console.log(global.cat)
meow
undefined
> 
(To exit, press ^C again or type .exit)
> 
$ 

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Running a Program with Node
-----------------------------
4 min
Node was designed with server-side web development in mind and has a lot of thoughtful functionality towards that end. At its most simple, however, it provides the ability to run 
JavaScript programs on our own computers instead of just in the browser’s console or embedded in HTML.

In this lesson, we’ll explore some of the functionality and properties specific to the Node environment, but first, let’s see how we run a program.

We’ll need to create a file with a .js extension. We’ll call ours myProgram.js. Next, we’ll open that file with a text editor and add our code:

// Inside myProgram.js
console.log('Hello World');

Our code is complete! Now, we want to execute it. We’ll open our terminal and navigate to the directory that contains myProgram.js. Finally, we’ll type the command node myProgram.js into 
our terminal.

$ node myProgram.js

The results of our program will print to the terminal.

Hello World

Let’s write a program and run it in Node.

* Instructions
--------------
Checkpoint 1 Passed
1.
We’ve written a silly sentence JavaScript program in the app.js file. There are a number of variables assigned the string '____'. Replace each of them with words of the designated type:

let adjective = 'silly';

When you’re ready to move on to the next step, click the “Check Work” button.

Checkpoint 2 Passed
2.
Let’s run the program in the terminal so we can see its output. Type node app.js in the terminal and press enter and then press “Check Work”. You should see the output of the program in 
the terminal!

app.js
------
let noun1 = 'man who walked on the moon';
let adjective = 'loyal and naive';
let noun2 = 'hillbilly'
let verb = 'watch and swallow the lies of the u.s government on tv';
let noun3 = 'chips and beer';


console.log(`The world's first ${noun1} was a very ${adjective} ${noun2} who loved to ${verb} while eating ${noun3} for every meal.`);

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Accessing the Process Object
------------------------------
13 min
In computer science, a process is the instance of a computer program that is being executed. You can open Task Manager if you’re on a Windows machine or Activity Monitor from a Mac to see 
information about the various processes running on your computer right now. Node has a global process object with useful methods and information about the current process.

The process.env property is an object which stores and controls information about the environment in which the process is currently running. For example, the process.env object contains a PWD property which holds a string with the directory in which the current process is located. It can be useful to have some if/else logic in a program depending on the current environment— a web application in a development phase might perform different tasks than when it’s live to users. We could store this information on the process.env. One convention is to add a property to process.env with the key NODE_ENV and a value of either production or development.

if (process.env.NODE_ENV === 'development'){
  console.log('Testing! Testing! Does everything work?');
}

The process.memoryUsage() returns information on the CPU demands of the current process. It returns a property that looks similar to this:

{ rss: 26247168,
  heapTotal: 5767168,
  heapUsed: 3573032,
  external: 8772 }

Heap can mean different things in different contexts: a heap can refer to a specific data structure, but it can also refer to the a block of computer memory. 
process.memoryUsage().heapUsed will return a number representing how many bytes of memory the current process is using.

The process.argv property holds an array of command line values provided when the current process was initiated. The first element in the array is the absolute path to Node, which ran the 
process. The second element in the array is the path to the file that’s running. The following elements will be any command line arguments provided when the process was initiated. Command 
line arguments are separated from one another with spaces.

node myProgram.js testing several features

console.log(process.argv[3]); // Prints 'several'

We’ve only covered a few of the properties of the process object, so make sure to check out the documentation on the process object to learn more about it and explore some of its other 
methods and properties.

Let’s get some practice using the process object!

* Instructions
--------------
Checkpoint 1 Passed
1.
We want the program in app.js to store the starting amount of memory used (heapUsed), perform an operation, and then compare the final amount of memory used to the original amount. Right 
now, the initialMemory variable is assigned to null. Change this line, so that initialMemory is instead assigned the value of the heapUsed property on the object returned from invoking 
the process.memoryUsage() method.


Hint
The process.memoryUsage() method returns an object that looks similar to this:

{ rss: 26247168,
  heapTotal: 5767168,
  heapUsed: 3573032,
  external: 8772 }

It has a property in it with the key heapUsed. We can access that property using dot notation:

process.memoryUsage().heapUsed // Returns 3573032

Checkpoint 2 Passed
2.
We want the user of the program to be able to fill in their own word when they run the program. Right now word is assigned to null. Change the program so that when a user initiates the 
program with an additional command line argument, word will be assigned that value. For example, running the program with the command: node app.js Codecademy would result in word being 
assigned the value 'Codecademy'


Hint
When we initiate the program with the command node app.js Codecademy, the first element in the process.argv array is the file path to Node, the second is the file path to the location 
program file, and the third is the string 'Codecademy'. In app.js, we’ll want to assign word to this third element in the array:

let word = process.argv[2];

Checkpoint 3 Passed
3.
Awesome! Now let’s run the program. Type node app.js followed by any word you like and then hit enter.


Hint
Initiate the process with any additional command line argument you like. For example, you can type node app.js Codecademy and then press enter.

app.js
------
let initialMemory = process.memoryUsage().heapUsed;
let word = process.argv[2];

console.log(`Your word is ${word}`)

// Create a new array
let wordArray = [];

// Loop 1000 times, pushing into the array each time 
for (let i = 0; i < 1000; i++){
  wordArray.push(`${word} count: ${i}`)
}

console.log(`Starting memory usage: ${initialMemory}. \nCurrent memory usage: ${process.memoryUsage().heapUsed}. \nAfter using the loop to add elements to the array, the process is using 
${process.memoryUsage().heapUsed - initialMemory} more bytes of memory.`)

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Core Modules and Local Modules
--------------------------------
11 min
Modularity is a software design technique where one program has distinct parts each providing a single piece of the overall functionality. These separate modules come together to build a 
cohesive whole. Modularity is essential for creating scalable programs which incorporate libraries and frameworks and separate the program’s concerns into manageable chunks. Essentially, 
a module is a collection of code located in a file. Instead of having an entire program located in a single file, code is organized into separate files and combined through requiring them 
where needed using the require() function.

To save developers from having to reinvent the wheel each time, Node has several modules included within the environment to efficiently perform common tasks. These are known as the core 
modules. The core modules are defined within Node.js’s source and are located in the lib/ folder. Core modules are required by passing a string with the name of the module into the 
require() function:

// Require in the 'events' core module:
let events = require('events');

We can use the same require() function to require modules of our own creation. To handle these different tasks, the require() function includes some interesting logic “under the hood.” 
The require() function will first check to see if its argument is a core module, if not, it will move on to different attempts to locate it. Check out the Node Modules documentation to 
learn more about how require() works.

Let’s walk through the process of requiring a local module:

// dog.js
module.exports = class Dog {

  constructor(name) {
    this.name = name;
  }

  praise() {
    return `Good dog, ${this.name}!`;
  }
};

Above, in the dog.js file, we assign the Dog class as the value of module.exports. Each JavaScript file in the Node environment has a special JavaScript object called module.exports. It 
holds everything in that file, or module, that’s available to be required into a different file.

// app.js
let Dog = require('./dog.js');
const tadpole = new Dog('Tadpole');
console.log(tadpole.praise());

In our app.js file we assign the variable Dog to the module.exports object of our dog.js file by invoking the require() function. Unlike when we require core modules which are required in 
with the name of the module as a string, local modules are required by passing in the path to the module. The require() function has some other quirks, like assuming file extensions if 
none are provided; this means we could have written let Dog = require('./dog'); in place of let Dog = require('./dog.js'); in the code above, and the require() function would have still 
correctly located and required in dog.js.

* Instructions
--------------
Checkpoint 1 Passed
1.
We wrote a program where a Dog can fight a Cat, but it doesn’t work yet because we haven’t properly connected our code. We created two modules: cat.js, which contains our Cat class, and 
dog.js, which contains our Dog class. But we need to assign these modules to their module.exports. Let’s start with cat.js. Inside cat.js assign the Cat class as the value of 
module.exports.


Hint
There are a couple ways to do this. For example, your cat.js file could look like this:

module.exports = class Cat {
  constructor(name, clawStrength) {
    this.name = name;
    this.clawStrength = clawStrength;
  }
};

Checkpoint 2 Passed
2.
We’ll also need to export our Dog class. Navigate to dog.js and assign the Dog class as the value of module.exports.


Hint
There are a couple ways to do this. For example, your dog.js file could look like this:

module.exports = class Dog {
  constructor(name, toothStrength) {
    this.name = name;
    this.toothStrength = toothStrength;
  }
};

Checkpoint 3 Passed
3.
Great! Now our Dog and Cat classes are being exported, but we still need to require them into app.js for our function to work properly. At the top of the app.js file, create a variable Dog and assign as its value invoking the require() function with the relative path of the dog.js file. Next, create a Cat variable and assign as its value invoking the require() function with the relative path of the cat.js file.


Hint
The top of your app.js file should have these two lines:

let Cat = require('./cat.js');
let Dog = require('./dog.js');

Checkpoint 4 Passed
4.
Let’s see this program in action! Use the node command to run app.js from the terminal.

cat.js
------
module.exports = class Cat {
  constructor(name, clawStrength) {
    this.name = name;
    this.clawStrength = clawStrength;
  }
};

dog.js
------
module.exports = class Dog {
  constructor(name, toothStrength) {
    this.name = name;
    this.toothStrength = toothStrength;
  }
};

app.js
------
// Require modules in:
const Dog = require('./dog');
const Cat = require('./cat');



let fight = (dog, cat) => {
    if (dog.toothStrength > cat.clawStrength) {
        console.log(`${dog.name} wins!`);
    }
    else if (dog.toothStrength < cat.clawStrength) {
        console.log(`${cat.name} wins!`);
    }
    else {
        console.log(`${dog.name} and ${cat.name} are equally skilled fighters!`);

    }
}

const myDog = new Dog('Rex', Math.random());
const myCat = new Cat('Tabby', Math.random());

fight(myDog, myCat);

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Node Package Manager
----------------------
1 min
In addition to local modules and core modules, we can take advantage of third-party modules. Using libraries created by other developers is an essential aspect of production; we don’t 
have to reinvent the wheel each time we want to include new functionality into our applications. NPM, which stands for Node Package Manager, is an online collection, or registry, of 
software. Developers can share code they’ve written to the registry or download code provided by other developers.

When we download Node, the npm command-line tool is downloaded as well, which enables us to interact with the registry via our terminal. There are hundreds of thousands of packages of 
re-usable code in the NPM registry including powerful and popular frameworks like express and react. You can explore the collection at the npm website.

One package we like is nodemon. It’s a powerful tool for development in Node that watches all the files in a project you’re working on, and automatically restarts your application when 
any of them change.

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Event-Driven Architecture
---------------------------
11 min
Node is often described as having event-driven architecture. Let’s explore what that means.

In traditional imperative programming, we give the computer a series of instructions to execute in a pre-defined order. In contrast, when we write web applications, we often need to write 
logic to handle situations without knowing exactly when they’ll occur. For example, when programming a website, we might provide functionality for a click event without knowing when a 
user will trigger it. When Node was created, it applied this same concept of event-driven principles to the back-end environment.

Node provides an EventEmitter class which we can access by requiring in the events core module:

// Require in the 'events' core module
let events = require('events');

// Create an instance of the EventEmitter class
let myEmitter = new events.EventEmitter();

Each event emitter instance has an .on() method which assigns a listener callback function to a named event. The .on() method takes as its first argument the name of the event as a string 
and, as its second argument, the listener callback function.

Each event emitter instance also has an .emit() method which announces a named event has occurred. The .emit() method takes as its first argument the name of the event as a string and, as 
its second argument, the data that should be passed into the listener callback function.

let newUserListener = (data) => {
  console.log(`We have a new user: ${data}.`);
};

// Assign the newUserListener function as the listener callback for 'new user' events
myEmitter.on('new user', newUserListener)

// Emit a 'new user' event
myEmitter.emit('new user', 'Lily Pad') //newUserListener will be invoked with 'Lily Pad'

Let’s create an event emitter!

* Instructions
--------------
Checkpoint 1 Passed
1.
In app.js, we’ve required in the events core module and written a function listenerCallback which expects to be passed data and will log a string to the console which incorporates that 
data. Now it’s time to create an event emitter. Create a new variable, myEmitter and assign as its value a new instance of the event emitter class.


Hint
You’ll do this by invoking EventEmitter():

let myEmitter = new events.EventEmitter();

Checkpoint 2 Passed
2.
Invoke myEmitter‘s .on() method passing in 'celebration' as the event name and listenerCallback as the listener callback function.


Hint
An event emitter’s .on() method takes as its the name of the event as a string as its first argument and, the listener callback function as its second argument.

someEmitter.on('name of event', callbackFunction);

Checkpoint 3 Passed
3.
Let’s emit a 'celebration' event! Invoke myEmitter‘s .emit() method passing in 'celebration' as the event name and a string of your choice as the second argument.


Hint
If you like to celebrate good times, you might want to pass in 'good times, come on!' as your second argument:

myEmitter.emit('celebration', 'good times, come on!');

Checkpoint 4 Passed
4.
Let’s see this program run! Use the node command to run app.js from the terminal.

app.js
------
// Here we require in the 'events' module and save a reference to it in an events variable
let events = require('events');

let listenerCallback = (data) => {
    console.log('Celebrate ' + data);
}

let myEmitter = new events.EventEmitter();

myEmitter.on('celebration', listenerCallback);

myEmitter.emit('celebration', 'New Year');

------------------------------------------------------------------------------------------------------------------------------------------------------------------

Asynchronous JavaScript with Node.js
5 min
In server-side development, we often perform time-consuming tasks such as reading files or querying a database. Instead of halting the execution of our code to await these operations or 
using multiple threads like other back end environments, Node was designed to use an event loop like the one used in browser-based JavaScript execution. The event-loop enables 
asynchronous actions to be handled in a non-blocking way.

Node provides a number of APIs for performing asynchronous tasks which expect callback functions to be passed in as arguments. Under the hood, these APIs trigger the subscription to and 
emitting of events to signal the completion of the operation. When the operation completes, the callback function is added to a queue, or line, of tasks waiting for their turn to be 
executed. When the current stack, or list, or synchronous tasks finish executing, the operations on the queue will be performed.

This means if synchronous tasks never end, operations waiting in the event-queue would never have the chance to run. Take a look at the following example code using the asynchronous Node 
setTimeout() API which asynchronously executes a provided callback function after a given delay:

let keepGoing = true;

let callback = () => {
  keepGoing = false;
};

setTimeout(callback, 1000); // Run callback after 1000ms

while(keepGoing === true) {
  console.log(`This is the song that never ends. Yes, it just goes on and on my friends. Some people started singing it, not knowing what it was, and they'll continue singing it forever 
just because...`)
};

This while-loop will continue forever! Even though the callback changing the keepGoing variable to false is added to the event queue after 1 second, it will never have a chance to 
run— the synchronous code from the loop will always fill the stack! If we wanted to avoid the infinite loop, we could replace the while-loop with an asynchronous function— for example, 
the Node setInterval() API.

Note: The modern way of handling asynchronous tasks is through JavaScript Promises (developers also favor the newer async...await syntax). If you’re not familiar with these topics, check 
out our lessons on them. Newer versions of Node (v8.0.0 and later) provide a collection of the traditional Node asynchronous APIs formatted for promises instead of callbacks. This can be 
found on util.promisify. Many contemporary 3rd party libraries also favor promise-based patterns over traditional callbacks.

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* User Input/Output
-------------------
10 min
If you’ve worked with JavaScript before, you’re likely familiar with the concept of input/output even if you haven’t heard it called that. At its most abstract, output is any data or 
feedback that a computer provides (like to a human user), while input is data provided to the computer. When we use console.log() we prompt the computer to output information to the 
console. In the Node environment, the console is the terminal, and the console.log() method is a “thin wrapper” on the .stdout.write() method of the process object. stdout stands for 
standard output.

In Node, we can also receive input from a user through the terminal using the stdin.on() method on the process object:

process.stdin.on('data', (userInput) => {
  let input = userInput.toString()
  console.log(input)
});

Here, we were able to use .on() because under the hood process.stdin is an instance of EventEmitter. When a user enters text into the terminal and hits enter, a 'data' event will be fired 
and our anonymous listener callback will be invoked. The userInput we receive is an instance of the Node Buffer class, so we convert it to a string before printing.

* Instructions
--------------
Checkpoint 1 Passed
1.
We’ve gotten started making a number guessing game. We’ve written a function playGame() which expects a line of user input corresponding to a guess. Input read through the terminal is 
received as a Buffer object with a new line character at the end, so we’ve converted it to a string and trimmed off the unnecessary new line character. We then feed the processed input 
into the testNumber() function required in from game.js.

Read through the code and try to figure out what has been done and what is left to do to make this an interactive command line program (game.js includes the core game logic, but reading 
through it is optional).

Checkpoint 2 Passed
2.
Everything about the game is complete except for reading input from the user. Based on what you’ve learned about getting user input from the terminal, complete the game.


Hint
We wrote the playGame() function, but it’s never invoked! Where should this happen?

We need to assign playGame() as the listener callback function so that it’s invoked any time process.stdin emits a 'data' event.

process.stdin.on('name of event', listenerCallbackFunction);

Checkpoint 3 Passed
3.
Awesome! Let’s play! Run app.js and play the game.

game.js
-------
let secretValue = Math.floor(1+Math.random()*10).toString();

let numbers = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10'];

module.exports = {
  testNumber: (input) => {
   if (input === 'quit') {
    process.stdout.write('Ok. Bye!\n')
    process.exit();
  }
  if (!numbers.includes(input)) {
    process.stdout.write('Choose a number from 1 through 10!\nIs the number ... ')
  } else if (input === secretValue) {
    process.stdout.write('Woah you got it! Are you psychic? See you later!\n')
    process.exit();
  } else {
    process.stdout.write("Nope. Guess again!\nIs the number ... ");
  }
  }
}

app.js
------
let {testNumber} = require('./game.js');

process.stdout.write("I'm thinking of a number from 1 through 10. What do you think it is? \n(Write \"quit\" to give up.)\n\nIs the number ... ");

let playGame = (userInput) => {
  let input = userInput.toString().trim();
	testNumber(input);
};

process.stdin.on('data', playGame);

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Errors
--------
8 min
The Node environment has all the standard JavaScript errors such as EvalError, SyntaxError, RangeError, ReferenceError, TypeError, and URIError as well as the JavaScript Error class for 
creating new error instances. Within our own code, we can generate errors and throw them, and, with synchronous code in Node, we can use error handling techniques such as try...catch 
statements.

Many asynchronous Node APIs use error-first callback functions: callback functions which have an error as the first expected argument and the data as the second argument. If the 
asynchronous task results in an error, it will be passed in as the first argument to the callback function. If no error was thrown, the first argument will be undefined.

const errorFirstCallback = (err, data)  => {
  if (err) {
    console.log(`There WAS an error: ${err}`);
  } else {
     // err was falsy
      console.log(`There was NO error. Event data: ${data}`);
  }
}

* Instructions
--------------
Checkpoint 1 Passed
1.
In order to understand why Node uses error-first callbacks in many of its asynchronous APIs, let’s demonstrate that traditional try...catch statements won’t work for errors thrown during 
asynchronous operations.

In naiveAsyncErr.js, we require in the local api.js module which contains the api.naiveErrorProneAsyncFunction() method. This asynchronous method throws an error whenever it is passed the 
input 'problematic input'. We would want the try...catch statement in naiveAsyncErr.js to catch this error, but it cannot since the error is thrown asynchronously.

In the terminal, execute the naiveAsyncErr.js file. You’ll see that the intended output, Something went wrong. ${err}\n, wasn’t logged— meaning that the error was never caught.


Hint
Type node naiveAsyncErr.js in the terminal and press enter.

Checkpoint 2 Passed
2.
Now take a look at app.js. Here we wrote an error-first callback function. This callback does the error handling so there’s no need for a try...catch statement. This is how most Node 
asynchronous APIs are set up to handle errors. In app.js we require in the api.js module. This time, we’ll use an asynchronous method, api.errorProneAsyncApi(), designed to work like the 
asynchronous methods in Node.

At the botton of app.js, invoke the api.errorProneAsyncApi() method with 'problematic input' as the first argument and the error-first callback as the second.


Hint
We’ve provided errorFirstCallback for you:

api.errorProneAsyncApi('problematic input', errorFirstCallback);

Checkpoint 3 Passed
3.
Let’s run app.js in the terminal so we can see how it properly handles the error created during the asynchronous operation.


Hint
Type node app.js in the terminal and press enter.

naiveAsyncErr.js
----------------
const api = require('./api.js');

// Not an error-first callback
let callbackFunc = (data) => {
   console.log(`Something went right. Data: ${data}\n`);
};
  
try {
  api.naiveErrorProneAsyncFunction('problematic input', callbackFunc);
} catch(err) {
  console.log(`Something went wrong. ${err}\n`);
}


app.js
------
const api = require('./api.js');

// An error-first callback
let errorFirstCallback = (err, data) => {
  if (err) {
    console.log(`Something went wrong. ${err}\n`);
  } else {
    console.log(`Something went right. Data: ${data}\n`);
  }
};

api.errorProneAsyncApi('problematic input', errorFirstCallback);

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Filesystem
------------
10 min
All of the data on a computer is organized and accessed through a filesystem. When running JavaScript code on a browser, it’s important for a script to have only limited access to a 
user’s filesystem. This technique of isolating some applications from others is known as sandboxing. Sandboxing protects users from malicious programs and invasions of privacy.

In the back-end, however, less restricted interaction with the filesystem is essential. The Node fs core module is an API for interacting with the file system. It was modeled after the 
POSIX standard for interacting with the filesystem.

Each method available through the fs module has a synchronous version and an asynchronous version. One method available on the fs core module is the .readFile() method which reads data 
from a provided file:

const fs = require('fs');

let readDataCallback = (err, data) => {
  if (err) {
    console.log(`Something went wrong: ${err}`);
  } else {
    console.log(`Provided file contained: ${data}`);
  }
};

fs.readFile('./file.txt', 'utf-8', readDataCallback);

Let’s walk through the example above:

	. We required in the fs core module.

	. We define an error-first callback function which expects an error to be passed as the first argument and data as the second. If the error is present, the function will print 
	Something went wrong: ${err}, otherwise, it will print Provided file contained: ${data}.

	. We invoked the .readFile() method with three arguments:
		1. The first argument is a string that contains a path to the file file.txt.

		2. The second argument is a string specifying the file’s character encoding (usually ‘utf-8’ for text files).

		3. The third argument is the callback function to be invoked when the asynchronous task of reading from the file system is complete. Node will pass the contents of 
		file.txt into the provided callback as its second argument.

* Instructions
--------------
Checkpoint 1 Passed
1.
We’ve created a devious treasure hunt for you! Your task is to use fs.readFile() to figure out the secret word and assign that value to the secretWord variable in app.js. Here’s your 
first clue, found scratched into walls of an abandoned castle: fileOne.txt.

There are many ways to complete this treasure hunt! You could write one program in app.js to solve the puzzle or you can run app.js to gain new insight and then change the program based 
on what you’ve figured out.

If you want some direction, but aren’t quite ready to check out the hint: we suggest you use the fs.readFile() method to print the contents of fileOne.txt.


Hint
We created the following error-first callback function to start:

let readDataCallback = (err, data) => {
  if (err) {
    console.log(`Something went wrong: ${err}`);
  } else {
    console.log(`Provided file contained: ${data}`);
  }
}; 

Next we ran:

fs.readFile('./fileOne.txt', 'utf-8', readDataCallback);

This gave us the clue that the next file was called anotherFile.txt, so we ran:

fs.readFile('./anotherFile.txt', 'utf-8', readDataCallback);

That gave us the clue that the next file was called finalFile.txt, so we ran:

fs.readFile('./finalFile.txt', 'utf-8', readDataCallback);

That gave us the secret word!

app.js
------
const fs = require('fs');

let readDataCallback = (err, data) => {
  if (err) {
    console.log(`Something went wrong: ${err}`);
  } else {
    console.log(`Provided file contained: ${data}`);
  }
};

fs.readFile('./finalFile.txt', 'utf-8', readDataCallback);

let secretWord = 'cheeseburgerpizzabagels';

bash
----
$ node app.js
Provided file contained: Not there yet! You must look in the file anotherFile.txt
$ node app.js
Provided file contained: So close, and yet so far. Perhaps if you look in finalFile.txt
$ node app.js
Provided file contained: The ancient scroll! It's beautiful! It says the secret word is ... "cheeseburgerpizzabagels".

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Readable Streams
------------------
10 min
In the previous exercise, we practiced reading the contents of entire files into our JavaScript programs. In more realistic scenarios, data isn’t processed all at once but rather 
sequentially, piece by piece, in what is known as a stream. Streaming data is often preferable since you don’t need enough RAM to process all the data at once nor do you need to have all 
the data on hand to begin processing it.

One of the simplest uses of streams is reading and writing to files line-by-line. To read files line-by-line, we can use the .createInterface() method from the readline core 
module. .createInterface() returns an EventEmitter set up to emit 'line' events:

const readline = require('readline');
const fs = require('fs');

const myInterface = readline.createInterface({
  input: fs.createReadStream('text.txt')
});

myInterface.on('line', (fileLine) => {
  console.log(`The line read: ${fileLine}`);
});

Let’s walk through the above code:

	. We require in the readline and fs core modules.

	. We assign to myInterface the returned value from invoking readline.createInterface() with an object containing our designated input.

	. We set our input to fs.createReadStream('text.txt') which will create a stream from the text.txt file.

	. Next we assign a listener callback to execute when line events are emitted. A 'line' event will be emitted after each line from the file is read.

	. Our listener callback will log to the console 'The line read: [fileLine]', where [fileLine] is the line just read.

Let’s practice making a readable stream.

* Instructions
--------------
Checkpoint 1 Passed
1.
You’re going to create a program that reads each item off of a shopping list (located in shoppingList.txt) and prints it to the console. Let’s take it one step at a time.

Create a myInterface variable. Assign myInterface the value returned from invoking readline.createInterface().

You’ll want to invoke readline.createInterface() with an object with a key of input and a value of fs.createReadStream(). Remember that fs.createReadStream() expects the file 
(as a string) from which it should read.


Hint
const myInterface = readline.createInterface({
  input: fs.createReadStream('shoppingList.txt')
});

Checkpoint 2 Passed
2.
Great work. Let’s create a listener callback function to use in the next step. Name this function printData. printData() should expect to receive some data (we named our parameter data) 
and it should log that data to the console in the format: Item: [data], where [data] is the argument passed into the function.


Hint
Here’s our printData() function looks:

const printData = (data) => {
  console.log(`Item: ${data}`);
};

Checkpoint 3 Passed
3.
We’re nearly there! Remember that a 'line' event will be emitted after each line from the file is read. Let’s assign our printData() function to execute whenever a 'line' event is emitted 
by using myInterface‘s .on() method.


Hint
myInterface.on('line', printData);

Checkpoint 4 Passed
4.
Sweet! Let’s run the program in the terminal. Type node app.js in the terminal and press enter. If everything worked, each item from the shopping list should be printed to the terminal.

shoppingList.txt
----------------
apples
pears
royal jelly
bread
milk
tofu
beans
flan
pork
tamarind

app.js
------
const readline = require('readline');
const fs = require('fs');

const myInterface = readline.createInterface({
  input: fs.createReadStream('shoppingList.txt')
});

const printData = (data) => {
  console.log(`Item: ${data}`);
}

myInterface.on('line', printData);

bash
----
node app.js
Item: apples
Item: pears
Item: royal jelly
Item: bread
Item: milk
Item: tofu
Item: beans
Item: flan
Item: pork
Item: tamarind

------------------------------------------------------------------------------------------------------------------------------------------------------------------



































































































































































































































































































































